{"title":"Anomalous ECG Detection","markdown":{"yaml":{"title":"Anomalous ECG Detection","author":"Anika Thatavarthy","description":"Determining whether an ECG is irregular or not using reconstruction via Autoencoders","image":"ecg.jpg","date":"2023-12-06","categories":["code"],"jupyter":"python3"},"headingText":"Determining whether an ECG is irregular or not using reconstruction via Autoencoders","containsRefs":false,"markdown":"\n\n\n```{python}\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport tensorflow as tf\n```\n\nDoes this show up\n\n```{python}\ndf = pd.read_csv('./ecg.csv', header=None)\nraw_data = df.values\ndf.head()\n```\n\n```{python}\nfrom sklearn.model_selection import train_test_split\n\nlabels = raw_data[:, -1]\ndata = raw_data[:, 0:-1]\n\nx_train, x_test, Y_train, Y_test = train_test_split(data, labels, test_size=0.2, random_state=42)\n```\n\n```{python}\n# scaling the data values\nmin_val = tf.reduce_min(x_train)\nmax_val = tf.reduce_max(x_train)\nx_train = (x_train - min_val) / (max_val - min_val)\nx_test = (x_test - min_val) / (max_val - min_val)\nx_train = tf.cast(x_train, tf.float32)\nx_test = tf.cast(x_test, tf.float32)\n```\n\n```{python}\n# formatting the labels\nY_train = Y_train.astype(bool)\nY_test = Y_test.astype(bool)\n\n# segregating the normal and irregular ECG observations\nnormal_x_train = x_train[Y_train]\nirregular_x_train = x_train[~Y_train]\n\nnormal_x_test = x_test[Y_test]\nirregular_x_test = x_test[~Y_test]\n```\n\n```{python}\n# plotting the normal and irregular ECG observations\nfig, ax = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))\nax[0].plot(np.arange(140), normal_x_train[-1])\nax[0].set_title('Normal ECG')\nax[0].grid()\nax[1].plot(np.arange(140), irregular_x_train[-1])\nax[1].set_title('Irregular ECG')\nax[1].grid()\n```\n\n```{python}\nfrom tensorflow.keras.models import Model\n\nclass Autoencoder(Model):\n  def __init__(self):\n    super(Autoencoder, self).__init__()\n    self.encoder = tf.keras.Sequential([\n      tf.keras.layers.Dense(140, activation='relu'),\n      tf.keras.layers.Dense(32, activation='relu'),\n      tf.keras.layers.Dense(16, activation='relu'),\n      tf.keras.layers.Dense(8, activation='relu'),\n    ])\n    self.decoder = tf.keras.Sequential([\n      tf.keras.layers.Dense(16, activation='relu'),\n      tf.keras.layers.Dense(32, activation='relu'),\n      tf.keras.layers.Dense(140, activation='sigmoid'),\n    ])\n\n  def call(self, x):\n    encoded = self.encoder(x)\n    decoded = self.decoder(encoded)\n    return decoded\n```\n\n```{python}\nautoencoder = Autoencoder()\n```\n\n```{python}\n# compiling and training the model\nautoencoder.compile(optimizer='adam', loss='mae')\nautoencoder.fit(normal_x_train, normal_x_train, epochs = 20, batch_size=512, validation_data=(normal_x_test, normal_x_test))\n```\n\n```{python}\nimport random\ndef plot(data, n, title):\n  enc_img = autoencoder.encoder(data)\n  dec_img = autoencoder.decoder(enc_img)\n  plt.plot(data[n], 'b')\n  plt.title(title)\n  plt.xlabel(\"Time\")\n  plt.ylabel(\"Amplitude\")\n  plt.plot(dec_img[n], 'r')\n  plt.fill_between(np.arange(140), data[n], dec_img[n], color = 'lightcoral')\n  plt.legend(labels=['Input', 'Reconstruction', 'Error'])\n  plt.show()\n\nplot(normal_x_test, random.randint(0, len(normal_x_test)), \"Normal ECG Reconstruction\")\nplot(irregular_x_test, random.randint(0, len(irregular_x_test)), \"Irregular ECG Reconstruction\")\n```\n\n```{python}\n# calculating the training loss\nreconstructions = autoencoder.predict(normal_x_train)\ntrain_loss = tf.keras.losses.mean_squared_error(reconstructions, normal_x_train)\n```\n\n```{python}\nthreshold = np.mean(train_loss) + np.std(train_loss)\n```\n\n```{python}\nreconstructed_test = autoencoder.predict(x_test)\n\nlosses = tf.keras.losses.mean_squared_error(reconstructed_test, x_test)\nanomalies = tf.math.less(losses, threshold)\n```\n\n```{python}\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score\nprint(str.format('Accuracy: {:.2f}', accuracy_score(Y_test, anomalies)))\nprint(str.format('Precision: {:.2f}', precision_score(Y_test, anomalies)))\nprint(str.format('Recall: {:.2f}', recall_score(Y_test, anomalies)))\n```\n\n","srcMarkdownNoYaml":"\n\n### Determining whether an ECG is irregular or not using reconstruction via Autoencoders\n\n```{python}\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport tensorflow as tf\n```\n\nDoes this show up\n\n```{python}\ndf = pd.read_csv('./ecg.csv', header=None)\nraw_data = df.values\ndf.head()\n```\n\n```{python}\nfrom sklearn.model_selection import train_test_split\n\nlabels = raw_data[:, -1]\ndata = raw_data[:, 0:-1]\n\nx_train, x_test, Y_train, Y_test = train_test_split(data, labels, test_size=0.2, random_state=42)\n```\n\n```{python}\n# scaling the data values\nmin_val = tf.reduce_min(x_train)\nmax_val = tf.reduce_max(x_train)\nx_train = (x_train - min_val) / (max_val - min_val)\nx_test = (x_test - min_val) / (max_val - min_val)\nx_train = tf.cast(x_train, tf.float32)\nx_test = tf.cast(x_test, tf.float32)\n```\n\n```{python}\n# formatting the labels\nY_train = Y_train.astype(bool)\nY_test = Y_test.astype(bool)\n\n# segregating the normal and irregular ECG observations\nnormal_x_train = x_train[Y_train]\nirregular_x_train = x_train[~Y_train]\n\nnormal_x_test = x_test[Y_test]\nirregular_x_test = x_test[~Y_test]\n```\n\n```{python}\n# plotting the normal and irregular ECG observations\nfig, ax = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))\nax[0].plot(np.arange(140), normal_x_train[-1])\nax[0].set_title('Normal ECG')\nax[0].grid()\nax[1].plot(np.arange(140), irregular_x_train[-1])\nax[1].set_title('Irregular ECG')\nax[1].grid()\n```\n\n```{python}\nfrom tensorflow.keras.models import Model\n\nclass Autoencoder(Model):\n  def __init__(self):\n    super(Autoencoder, self).__init__()\n    self.encoder = tf.keras.Sequential([\n      tf.keras.layers.Dense(140, activation='relu'),\n      tf.keras.layers.Dense(32, activation='relu'),\n      tf.keras.layers.Dense(16, activation='relu'),\n      tf.keras.layers.Dense(8, activation='relu'),\n    ])\n    self.decoder = tf.keras.Sequential([\n      tf.keras.layers.Dense(16, activation='relu'),\n      tf.keras.layers.Dense(32, activation='relu'),\n      tf.keras.layers.Dense(140, activation='sigmoid'),\n    ])\n\n  def call(self, x):\n    encoded = self.encoder(x)\n    decoded = self.decoder(encoded)\n    return decoded\n```\n\n```{python}\nautoencoder = Autoencoder()\n```\n\n```{python}\n# compiling and training the model\nautoencoder.compile(optimizer='adam', loss='mae')\nautoencoder.fit(normal_x_train, normal_x_train, epochs = 20, batch_size=512, validation_data=(normal_x_test, normal_x_test))\n```\n\n```{python}\nimport random\ndef plot(data, n, title):\n  enc_img = autoencoder.encoder(data)\n  dec_img = autoencoder.decoder(enc_img)\n  plt.plot(data[n], 'b')\n  plt.title(title)\n  plt.xlabel(\"Time\")\n  plt.ylabel(\"Amplitude\")\n  plt.plot(dec_img[n], 'r')\n  plt.fill_between(np.arange(140), data[n], dec_img[n], color = 'lightcoral')\n  plt.legend(labels=['Input', 'Reconstruction', 'Error'])\n  plt.show()\n\nplot(normal_x_test, random.randint(0, len(normal_x_test)), \"Normal ECG Reconstruction\")\nplot(irregular_x_test, random.randint(0, len(irregular_x_test)), \"Irregular ECG Reconstruction\")\n```\n\n```{python}\n# calculating the training loss\nreconstructions = autoencoder.predict(normal_x_train)\ntrain_loss = tf.keras.losses.mean_squared_error(reconstructions, normal_x_train)\n```\n\n```{python}\nthreshold = np.mean(train_loss) + np.std(train_loss)\n```\n\n```{python}\nreconstructed_test = autoencoder.predict(x_test)\n\nlosses = tf.keras.losses.mean_squared_error(reconstructed_test, x_test)\nanomalies = tf.math.less(losses, threshold)\n```\n\n```{python}\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score\nprint(str.format('Accuracy: {:.2f}', accuracy_score(Y_test, anomalies)))\nprint(str.format('Precision: {:.2f}', precision_score(Y_test, anomalies)))\nprint(str.format('Recall: {:.2f}', recall_score(Y_test, anomalies)))\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"anomaly_detection.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","theme":"minty","title-block-banner":true,"title":"Anomalous ECG Detection","author":"Anika Thatavarthy","description":"Determining whether an ECG is irregular or not using reconstruction via Autoencoders","image":"ecg.jpg","date":"2023-12-06","categories":["code"],"jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}